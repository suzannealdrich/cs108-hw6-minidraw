// CCanvas.cp#include "CCanvas.h"#include "DrawConstants.h"#include "CDocumentApp.h"#include "CToolPalette.h"#include "CShape.h"#include "CRect.h"#include "CRoundRect.h"#include "COval.h"#include "CLine.h"#include "CShapeAction.h"CCanvas::CCanvas(LStream *inStream)	: LOffscreenView(inStream)  {	mDirty = false;}void CCanvas::FinishCreateSelf(){	CDocumentApp* theApp = (CDocumentApp*) LCommander::GetTopCommander();	mWindow = LWindow::FindWindowByID(kDrawWindowID);	mPalette = theApp->GetPalette();}void CCanvas::AdjustCursorSelf(Point inPortPt, const EventRecord& inMacEvent){	if (mPalette->GetCurrentTool() != msg_ArrowTool) {		CursHandle cursor = ::GetCursor(crossCursor);		if (cursor) ::SetCursor(*cursor);	}}void CCanvas::ClickSelf(const SMouseDownEvent& inMouseDown){	Point clickPt = inMouseDown.whereLocal;	int currentTool = mPalette->GetCurrentTool();	LCommander* previousTarget = LCommander::GetTarget();		if (currentTool == msg_ArrowTool) {		SwitchTarget(mWindow);		return;	}	SShapeInfo initInfo;	initInfo.startPt = initInfo.endPt = clickPt;	mPalette->GetFrameColor(initInfo.frameColor);	mPalette->GetFillColor(initInfo.fillColor);	CShape* newShape = CreateShape(mPalette->GetCurrentTool(), initInfo);	if (::StillDown()) {		UpdatePort();		while (::StillDown()) {			FocusDraw();			Point movedPt;			::GetMouse(&movedPt);			if (!::EqualPt(movedPt, clickPt)) {				SwitchTarget(newShape);				newShape->ResizeOrMove(clickPt, false, true);				UpdatePort();				break;			}		}	}	Point startPt, endPt;	newShape->GetStartEnd(startPt, endPt);	if (::EqualPt(startPt, endPt)) {		SwitchTarget(previousTarget);		DeleteShape(newShape);	} else {		CShapeAction* action = new CShapeAction(newShape, cmd_CreateShape, true);		mWindow->PostAction(action);	}}void CCanvas::DeleteShape(CShape* shape){	Refresh();	delete shape;}CShape* CCanvas::CreateShape(int classID, SShapeInfo& initInfo){	CShape* newShape = NewShapeByClass(classID);	newShape->OrientFromInfo(initInfo);	newShape->FinishCreate();	Refresh();	return newShape;}CShape* CCanvas::NewShapeByClass(int classID){	switch (classID) {		case msg_RectTool:		return new CRect((LView*) this, mWindow);		case msg_RoundRectTool:		return new CRoundRect((LView*) this, mWindow);			case msg_OvalTool:		return new COval((LView*) this, mWindow);			case msg_LineTool:		return new CLine((LView*) this, mWindow);			default:		return 0;	}}Boolean CCanvas::GetDirty() const{	return mDirty;}void CCanvas::SetDirty(Boolean inDirty){	mDirty = inDirty;}