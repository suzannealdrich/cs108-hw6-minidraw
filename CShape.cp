// CShape.cp#include "CShape.h"#include "CDrawUtils.h"#include "CDocumentApp.h"#include "CToolPalette.h"#include "CShapeAction.h"#include "CCanvas.h"CShape::CShape(LView* superCanvas, LWindow* superWindow)	: LPane() , LCommander(superWindow) {		SPaneInfo paneInfo;	paneInfo.paneID = 0;	paneInfo.width = paneInfo.height = 0;	paneInfo.top = paneInfo.left = 0;	paneInfo.userCon = 0;	paneInfo.visible = paneInfo.enabled = true;	paneInfo.bindings.left = paneInfo.bindings.top = 		paneInfo.bindings.right = paneInfo.bindings.bottom = false;		paneInfo.superView = superCanvas;	InitPane(paneInfo);	}void CShape::FinishCreateSelf(){	CDocumentApp* theApp = (CDocumentApp*) LCommander::GetTopCommander();	mPalette = theApp->GetPalette();}void CShape::OrientFromInfo(const SShapeInfo& init){	SetStartEnd(init.startPt, init.endPt);	SetFrameColor(init.frameColor);	SetFillColor(init.fillColor);}void CShape::GetInfo(SShapeInfo& outInfo) const {	outInfo.startPt		= mStartPt;	outInfo.endPt		= mEndPt;	outInfo.frameColor	= mFrameColor;	outInfo.fillColor	= mFillColor;}void CShape::SetStartEnd(Point start, Point end){	mStartPt = start;	mEndPt = end;	Rect frame;	CDrawUtils::CalcEnclosingRect(mStartPt, mEndPt, frame);	::InsetRect(&frame, -kKnobSize/2, -kKnobSize/2);	PlaceInSuperFrameAt(frame.left, frame.top, true);	ResizeFrameTo(frame.right - frame.left, frame.bottom - frame.top, true);	((CCanvas*) mSuperView)->SetDirty(true);	Refresh();}void CShape::CalcKnobRect(Rect &outRect, Point aroundPt) const{	::SetRect(&outRect, (aroundPt.h - kKnobSize/2), (aroundPt.v - kKnobSize/2), 						(aroundPt.h + kKnobSize/2), (aroundPt.v + kKnobSize/2));}void CShape::SetFrameColor(const RGBColor& newColor){	mFrameColor = newColor;	((CCanvas*) mSuperView)->SetDirty(true);		Refresh();}void CShape::SetFillColor(const RGBColor& newColor){	mFillColor = newColor;	((CCanvas*) mSuperView)->SetDirty(true);	Refresh();}void CShape::ClickSelf(const SMouseDownEvent& inMouseDown){	if (mPalette->GetCurrentTool() == msg_ArrowTool) {		Point clickPt = inMouseDown.whereLocal;		Boolean clickOnShape = IsClickOnShape(clickPt);		Rect knob;		CalcKnobRect(knob, mStartPt);		Boolean clickOnStart = PtInRect(clickPt, &knob);		CalcKnobRect(knob, mEndPt);		Boolean clickOnEnd = PtInRect(clickPt, &knob);		if (clickOnShape || clickOnStart || clickOnEnd) {			Boolean changed = false;			Boolean moveFlag =  !clickOnStart && !clickOnEnd;			CShapeAction* action = new CShapeAction(this, (moveFlag? cmd_MoveShape : cmd_ResizeShape), true);			if (!IsTarget())				SwitchTarget(this);			if (::StillDown()) {				UpdatePort();				while (::StillDown()) {					FocusDraw();					Point movedPt;					::GetMouse(&movedPt);					if (!::EqualPt(movedPt, clickPt)) {						// if neither knobbie was clicked, move both						// if both were clicked, shape is too small to move						if (clickOnStart == clickOnEnd) {							clickOnStart = !clickOnEnd; clickOnEnd = true;						}						Point startPt = mStartPt, endPt = mEndPt;						ResizeOrMove(clickPt, clickOnStart, clickOnEnd);						changed = !::EqualPt(startPt, mStartPt) || !::EqualPt(endPt, mEndPt);						break;					}				}			}			if (changed) {				action->SetNewStartEnd(mStartPt, mEndPt);				PostAction(action);			} else {				delete action;			}			return;		}	}	Disable();	mSuperView->Click(inMouseDown);	Enable();}void CShape::GetStartEnd(Point& start, Point& end){	start = mStartPt;	end = mEndPt;}Boolean CShape::IsClickOnShape(Point clickPt){	if ((GetClassInt() == msg_LineTool) || (mStartPt.h == mEndPt.h) || (mStartPt.v == mEndPt.v)) {		int onLine = CDrawUtils::PtOnLine(mStartPt.h, mStartPt.v, mEndPt.h, mEndPt.v, clickPt.h, clickPt.v);		return (onLine == 2);	}	RgnHandle region = ::NewRgn();	::OpenRgn();	DrawMyShape();	::CloseRgn(region);	Boolean inShape = ::PtInRgn(clickPt, region);	::DisposeRgn(region);	return inShape;}void CShape::ResizeOrMove(Point clickPt, Boolean moveStart, Boolean moveEnd){	Point startPt = mStartPt, endPt = mEndPt;	if (::StillDown) {		UpdatePort();		while (::StillDown()) {			FocusDraw();			Point lastPt = clickPt;			::GetMouse(&clickPt);			int dv = clickPt.v - lastPt.v;			int dh = clickPt.h - lastPt.h;			if (dv != 0 || dh != 0) {				if (moveStart) {					startPt.h += dh;					startPt.v += dv;				}				if (moveEnd) {					endPt.h += dh;					endPt.v += dv;				}				this->SetStartEnd(startPt, endPt);				UpdatePort();			}		}	}}void CShape::BeTarget(){	Refresh();}void CShape::DontBeTarget(){	Refresh();}void CShape::DrawSelf(){	DrawMyShape();	if (IsTarget()) {		DrawResizeKnobs();	}}void CShape::AdjustCursorSelf(Point inPortPt, const EventRecord& inMacEvent){	if (mPalette->GetCurrentTool() != msg_ArrowTool) {		CursHandle cursor = ::GetCursor(crossCursor);		if (cursor) ::SetCursor(*cursor);	}}void CShape::DrawResizeKnobs(){	Rect knob;	CalcKnobRect(knob, mStartPt);	::InvertRect(&knob);	CalcKnobRect(knob, mEndPt);	::InvertRect(&knob);	}Boolean CShape::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean	cmdHandled = false;	RGBColor newColor;		switch (inCommand) {		case cmd_SetFrameColor:			if (PromptForColor(mFrameColor, newColor)) {				CShapeAction* action = new CShapeAction(this, inCommand);				action->SetNewColor(newColor);				PostAction(action);			}			break;		case cmd_SetFillColor:			if (PromptForColor(mFillColor, newColor)) {				CShapeAction* action = new CShapeAction(this, inCommand);				action->SetNewColor(newColor);				PostAction(action);			}			break;					case cmd_Clear:			CShapeAction* action = new CShapeAction(this, cmd_DeleteShape);			PostAction(action);			cmdHandled = true;			break;									default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}void CShape::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	switch (inCommand) {		case cmd_SetFrameColor:			outEnabled = true;			break;		case cmd_SetFillColor:			outEnabled = true;			break;					case cmd_Clear:			outEnabled = true;			break;								default:			LCommander::FindCommandStatus(inCommand, outEnabled,										outUsesMark, outMark, outName);			break;	}}Boolean CShape::HandleKeyPress(const EventRecord &inKeyEvent){	Char16 theKey = inKeyEvent.message;	if ((theKey & charCodeMask) == char_Backspace) {		CShapeAction* action = new CShapeAction(this, cmd_DeleteShape);		PostAction(action);		return true;	} else {		return LCommander::HandleKeyPress(inKeyEvent);	}}Boolean CShape::PromptForColor(const RGBColor& oldColor, RGBColor& newColor){	Point where = {0, 0};	if (::GetColor(where, "\pShape Color", &oldColor, &newColor)) {			return true;	}	return false;}void CShape::WriteToStream(LStream* stream){	SShapeInfo writeInfo;	GetInfo(writeInfo);	stream->WriteData(&writeInfo, sizeof(writeInfo));}void CShape::OrientFromStream(LStream* stream){	SShapeInfo readInfo;	stream->ReadData(&readInfo, sizeof(readInfo));	OrientFromInfo(readInfo);}