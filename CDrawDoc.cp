// CDrawDoc.cp#include <LFile.h>#include <LPlaceHolder.h>#include <LPrintout.h>#include <LString.h>#include <LWindow.h>#include <PP_Messages.h>#include <UMemoryMgr.h>#include <UWindows.h>#include "CDrawDoc.h"#include "CCanvas.h"// ---------------------------------------------------------------------------------//		¥ CDrawDoc(LCommander*, FSSpec*)// ---------------------------------------------------------------------------------CDrawDoc::CDrawDoc(	LCommander	*inSuper,	FSSpec		*inFileSpec )		: LSingleDoc( inSuper ){	// Create window for our document.	mWindow = nil;	mWindow = LWindow::CreateWindow(kDrawWindowID, this );	ThrowIfNil_(mWindow);	mWindow->AddAttachment(new LUndoer());		// Create and attach the LUndoer												// Could attach to the Window or Application	// Specify that the view should be the	// target when the window is activated.		mCanvas = dynamic_cast<CCanvas *> (mWindow->FindPaneByID(kCanvasPaneID));	ThrowIfNil_( mCanvas != nil );	//mWindow->SetLatentSub( mCanvas );		if ( inFileSpec == nil ) {		// Set the name of new window.		NameNewDoc();			} else {			// Display contents of file in window.		OpenFile( *inFileSpec );		}		// Make the window visible.	mWindow->Show();}// ---------------------------------------------------------------------------------//		¥ NameNewDoc// ---------------------------------------------------------------------------------voidCDrawDoc::NameNewDoc(){	// Setup the window title. Start with the default title.	LStr255	theTitle( "\pUntitled" );	// Find the first available title. We could also check the window	// pane id if we wanted to make sure we didn't collide with other	// window types.	Int32	theNumber = 0;	while ( UWindows::FindNamedWindow( theTitle ) != nil ) {		// An existing window has the current name		// Increment counter and try again.		++theNumber;		theTitle = "\pUntitled ";		theTitle += static_cast<SInt32>(theNumber);	}				// Finally, set window title.	mWindow->SetDescriptor( theTitle );}// ---------------------------------------------------------------------------------//		¥ OpenFile// ---------------------------------------------------------------------------------voidCDrawDoc::OpenFile(	FSSpec	&inFileSpec ){  	mFile = nil;		// Create a new file object.	PP_PowerPlant::StDeleter<PP_PowerPlant::LFileStream>					theFile( new PP_PowerPlant::LFileStream( inFileSpec ) );		theFile->OpenDataFork( fsRdWrPerm );		ReadShapesFromStream(theFile.Get());		theFile->CloseDataFork();	// Set the window title to the name of the file and	// flag that the document has an associated file.	mWindow->SetDescriptor( inFileSpec.name );	mIsSpecified = true;	mFile = theFile.Release();	// take over ownership of the file object}// ---------------------------------------------------------------------------------//		¥ IsModified// ---------------------------------------------------------------------------------BooleanCDrawDoc::IsModified(){	// Document has changed if the view is dirty.	mIsModified = mCanvas->GetDirty();	return mIsModified;}// ---------------------------------------------------------------------------------//		¥ DoAESave// ---------------------------------------------------------------------------------voidCDrawDoc::DoAESave(	FSSpec	&inFileSpec,	OSType	inFileType ){	// Delete the existing file object.	// Note: this does nothing to the actual file on disk.	delete mFile;	mFile = nil;		// Make a new file object.	mFile = new PP_PowerPlant::LFileStream( inFileSpec );		// Get the proper file type.	OSType	theFileType = kDrawDocFileType;	if ( inFileType != PP_PowerPlant::fileType_Default ) {		theFileType = inFileType;	}		// Make new file on disk	mFile->CreateNewDataFile(kDrawDocFileType, theFileType, 0);	// data fork only	// Write out the data.	DoSave();	// Change window title to reflect the new name.	mWindow->SetDescriptor( inFileSpec.name );	// Document now has a specified file.	mIsSpecified = true;}// ---------------------------------------------------------------------------------//		¥ DoSave// ---------------------------------------------------------------------------------voidCDrawDoc::DoSave(){	mFile->OpenDataFork(fsRdWrPerm);		// ((LFileStream*)mFile)->SetMarker(0, streamFrom_Start);	WriteShapesToStream((LFileStream*)mFile);		// Set the length to the end our new data	// (necessary in case the file used to contain something bigger)	((LFileStream*)mFile)->SetLength(((LFileStream*)mFile)->GetMarker());		mFile->CloseDataFork();	// Saving makes doc un-dirty.	mCanvas->SetDirty( false );}// ---------------------------------------------------------------------------------//		¥ DoRevert// ---------------------------------------------------------------------------------voidCDrawDoc::DoRevert(){		TArrayIterator<LPane*> iterator(mCanvas->GetSubPanes());	LPane* pane;	while (iterator.Next(pane)) {		mCanvas->DeleteShape((CShape*) pane);	}		mFile->OpenDataFork(fsRdWrPerm);		ReadShapesFromStream((LFileStream*)mFile);		mFile->CloseDataFork();		// mCanvas->Refresh();}// ---------------------------------------------------------------------------------//		¥ WriteShapesToStream// ---------------------------------------------------------------------------------void CDrawDoc::WriteShapesToStream(LStream* stream){	TArrayIterator<LPane*> iterator(mCanvas->GetSubPanes());	LPane* pane;	CShape *shape;	while (iterator.Next(pane)) {		shape = (CShape*)pane; // could try some RTTI here if we were paranoid		int id = shape->GetClassInt();		stream->WriteData(&id, sizeof(id));		shape->WriteToStream(stream);	}}// ---------------------------------------------------------------------------------//		¥ ReadShapesFromStream// ---------------------------------------------------------------------------------void CDrawDoc::ReadShapesFromStream(LStream* stream){	int id;	CShape *shape;	while (stream->GetMarker() < stream->GetLength()) {		stream->ReadData(&id, sizeof(id));		shape = mCanvas->NewShapeByClass(id);		Assert_(shape);		shape->OrientFromStream(stream);		shape->FinishCreate();	}	mCanvas->SetDirty(false);}